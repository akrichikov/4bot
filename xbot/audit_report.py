from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, Iterable, List, Tuple


def _iter_jsonl(path: Path) -> Iterable[Dict[str, Any]]:
    if not path.exists():
        return []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                yield json.loads(line)
            except Exception:
                continue


def summarize_vterm_audit(path: Path) -> Dict[str, Any]:
    total = 0
    by_path: Dict[str, int] = {}
    auth_fail = 0
    rate_limited = 0
    exit_codes: Dict[str, int] = {}
    cmd_counts: Dict[str, int] = {}

    for rec in _iter_jsonl(path):
        total += 1
        p = str(rec.get("path") or "?")
        by_path[p] = by_path.get(p, 0) + 1
        if rec.get("auth") is False:
            auth_fail += 1
        if rec.get("rate_limited"):
            rate_limited += 1
        if p == "/run":
            ec = str(rec.get("exit_code"))
            exit_codes[ec] = exit_codes.get(ec, 0) + 1
            cmd = str(rec.get("cmd") or "")
            if cmd:
                cmd_counts[cmd] = cmd_counts.get(cmd, 0) + 1

    top_cmds = sorted(cmd_counts.items(), key=lambda kv: (-kv[1], kv[0]))[:10]
    return {
        "total": total,
        "by_path": by_path,
        "auth_fail": auth_fail,
        "rate_limited": rate_limited,
        "exit_codes": exit_codes,
        "top_cmds": top_cmds,
    }


def render_vterm_audit_html(summary: Dict[str, Any]) -> str:
    def tr(k: str, v: Any) -> str:
        return f"<tr><td>{k}</td><td>{v}</td></tr>"

    rows = []
    rows.append(tr("total", summary.get("total", 0)))
    rows.append(tr("auth_fail", summary.get("auth_fail", 0)))
    rows.append(tr("rate_limited", summary.get("rate_limited", 0)))

    by_path = summary.get("by_path", {})
    exit_codes = summary.get("exit_codes", {})
    top_cmds = summary.get("top_cmds", [])

    path_rows = "".join(tr(k, v) for k, v in sorted(by_path.items()))
    ec_rows = "".join(tr(k, v) for k, v in sorted(exit_codes.items()))
    cmd_rows = "".join(tr(k, v) for k, v in top_cmds)

    total_runs = sum(int(v) for v in summary.get('exit_codes', {}).values())
    return f"""
<!doctype html>
<html lang=\"en\">
<meta charset=\"utf-8\" />
<title>VTerm Audit Report</title>
<style>
 body {{ font-family: system-ui, Arial, sans-serif; margin: 20px; }}
 h1 {{ margin: 0 0 8px 0; }}
 table {{ border-collapse: collapse; margin: 10px 0; }}
 td, th {{ border: 1px solid #ccc; padding: 6px 10px; }}
 .muted {{ color: #666; }}
 .grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }}
 .card {{ border: 1px solid #ddd; border-radius: 8px; padding: 10px; }}
 .kpi {{ font-size: 22px; font-weight: 600; }}
 .label {{ font-size: 12px; color: #777; }}
 footer {{ margin-top: 20px; font-size: 12px; color: #777; }}
 </style>
<h1>VTerm Audit Report</h1>
<div class=\"grid\">
 <div class=\"card\"><div class=\"kpi\">{summary.get('total',0)}</div><div class=\"label\">Total Events</div></div>
 <div class=\"card\"><div class=\"kpi\">{summary.get('auth_fail',0)}</div><div class=\"label\">Auth Failures</div></div>
 <div class=\"card\"><div class=\"kpi\">{summary.get('rate_limited',0)}</div><div class=\"label\">Rate Limited</div></div>
 <div class=\"card\"><div class=\"kpi\">{total_runs}</div><div class=\"label\">Run Calls</div></div>
</div>

<h2>By Path</h2>
<table><tr><th>Path</th><th>Count</th></tr>{path_rows}</table>

<h2>Exit Codes</h2>
<table><tr><th>Exit Code</th><th>Count</th></tr>{ec_rows}</table>

<h2>Top Commands</h2>
<table><tr><th>Cmd</th><th>Count</th></tr>{cmd_rows}</table>

<footer class=\"muted\">Generated by xbot.audit_report</footer>
"""


def write_vterm_audit_report(log_path: Path, out_html: Path, out_json: Path | None = None) -> Dict[str, Any]:
    summary = summarize_vterm_audit(log_path)
    out_html.parent.mkdir(parents=True, exist_ok=True)
    out_html.write_text(render_vterm_audit_html(summary), encoding="utf-8")
    if out_json:
        out_json.parent.mkdir(parents=True, exist_ok=True)
        out_json.write_text(json.dumps(summary, ensure_ascii=False, indent=2), encoding="utf-8")
    return summary
